***Study Materials: 
https://github.com/bbatsov/ruby-style-guide
https://www.ruby-lang.org/en/


###Installing Ruby on Rails on CentOS 7, using rbenv**********************
#Install rbenv, which we will use to install and manage our Ruby installation. Install the rbenv and Ruby dependencies with yum
$sudo yum install -y git-core zlib zlib-devel gcc-c++ patch readline readline-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison curl sqlite-devel
#Now we are ready to install rbenv. The easiest way to do that is to run these commands, as the user that will be using Ruby
$cd
$git clone git://github.com/sstephenson/rbenv.git .rbenv
$echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bash_profile
$echo 'eval "$(rbenv init -)"' >> ~/.bash_profile
$exec $SHELL
$git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
$echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bash_profile
$exec $SHELL    #This installs rbenv into your home directory, and sets the appropriate environment variables that will allow rbenv to the active version of Ruby
#Now we're ready to install Ruby. Before using rbenv, determine which version of Ruby that you want to install. We will install the latest version, Ruby 2.2.1
#As the user that will be using Ruby, install it with these commands
$rbenv install -v 2.2.1
$rbenv global 2.2.1
#The global sub-command sets the default version of Ruby that all of your shells will use. If you want to install and use a different version, simply run the rbenv commands with a different version number
#Verify that Ruby was installed properly with this command
$ruby -v
#It is likely that you will not want Rubygems to generate local documentation for each gem that you install, as this process can be lengthy. To disable this, run this command
$echo "gem: --no-document" > ~/.gemrc
#You will also want to install the bundler gem, to manage your application dependencies
$gem install bundler
#As the same user, install Rails 4.2.0 with this command
$gem install rails -v 4.2.0
#Whenever you install a new version of Ruby or a gem that provides commands, you should run the rehash sub-command. This will install shims for all Ruby executables known to rbenv, which will allow you to use the executables
$rbenv rehash
#Verify that Rails has been installed properly by printing its version, with this command
$rails -v 
#A few Rails features, such as the Asset Pipeline, depend on a Javascript runtime. We will install Node.js to provide this functionality.
#Add the EPEL yum repository
$sudo yum -y install epel-release
#Then install the Node.js package
$sudo yum install nodejs
###Note: This will probably not install the latest release of Node.js, as Enterprise Linux does not consider it to be "stable". If you want to install the latest version, feel free to build it on your own
###Congratulations! Ruby on Rails is now installed on your system
###Testing the Ruby on Rails Installation 
#If you want to make sure that your Ruby on Rails installation went smoothly, you can quickly create a test application to test it out. For simplicity, our test application will use sqlite3 for its database
$cd ~
$rails new testapp
#Then move into the application's directory
$cd testapp
#Create the sqlite3 database
$rake db:create
#If you don't already know the public IP address of your server, look it up with this command
$ip addr show enp0s3 | grep inet | awk '{ print $2; }' | sed 's/\/.*$//'
#Copy the IPv4 address to your clipboard, then use it with this command to start your Rails application: (substitute the highlighted part with the IP address)
$rails server --binding=<server_public_IP>
###If it is working properly, your Rails application should be running on port 3000 of the public IP address of your server. Visit your Rails application by going there in a web browser
###http://server_public_IP:3000
*******************You're now ready to start developing your new Ruby on Rails application. Good luck!****************************************************************************************

###Install visual studio code*********************
#Create a new file /etc/yum.repos.d/vscode.repo and edit in text editor
touch /etc/yum.repos.d/vscode.repo
#Now add following content to the file
	[vscode]
	name=Visual Studio Code
	baseurl=https://packages.microsoft.com/yumrepos/vscode
	enabled=1
	gpgcheck=1
	gpgkey=https://packages.microsoft.com/keys/microsoft.asc
#Now, import the package signing gpg key on your system using the following command 
$sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 
#After importing gpg key, Letâ€™s use below commands to install Visual Studio Code on your RHEL based system
$yum check-update 	
$sudo yum install code 
#To open a file/folder with vscode 
$code --user-data-dir=./


	
###Install sublime Text******************
#Install the gpg key 
$sudo rpm -v --import https://download.sublimetext.com/sublimehq-rpm-pub.gpg
#Stable 
$sudo yum-config-manager --add-repo https://download.sublimetext.com/rpm/stable/x86_64/sublime-text.repo
#Dev
$sudo yum-config-manager --add-repo https://download.sublimetext.com/rpm/dev/x86_64/sublime-text.repo
#Update yum and install sublime text
$sudo yum install sublime-text

$rvm list
$rvm use ruby-2.3.0
$rails s -b $IP -p $PORT
$rails new newapp
$$rails server --binding=<server_public_IP>  #To start the rails server cd into the app directory 

#####installing updated version of git
sudo apt-add-repository ppa:git-core/ppa
sudo apt-get updated
sudo apt-get install git
# Copies the contents of the id_rsa.pub file to your clipboard
clip < ~/.ssh/id_rsa.pub
pbcopy < ~/.ssh/id_rsa.pub
#install ansible
sudo apt-get install ansible
#Generating ssh key pair
ssh-keygen
echo 'public_key' > authorized_keys
ssh-agent bash
ssh-add .ssh/id_rsa
#ping the machine
ansible -i hosts -u root -m ping all 


####Multi Line or Block Ruby Comments
#Multiple lines of text or code can be defined as comments using the Ruby =begin and =end comment markers. These are known as the 
#comment block markers. Example to provide a comment block containing multiple lines of descriptive text
=begin
This is a comment line 
it explains that the next line of code displays 
a welcome message
=end 
#Lines of Ruby code can be blocked out so that they are not executed by the interpreter using the block markers




#######################Declaring Constans and  Variables********************************************************************** 
=begin 
A Ruby constant is used to store a value for the duration of a Ruby program's execution. A common convention for declaring constants 
is to use uppercase letters for the entire name
Unlike other programming languages, Ruby actually allows the value assigned to a constant to be changed after it has been created
The Ruby interpreter will, however, issue a warning - even though it allows the change. Constants declared within a class or module are
available anywhere within the context of that class or module. Constants declared outside of a class or module are assigned global scope
=end

=begin
Ruby, is a dynamically typed language. It means that you do not need to declare a type when creating a variable. Instead, the Ruby interpreter
looks at the type of value you are assigning to the variable and dynamically works out the variable type. Once a variable has been declared
you can dynamically change the variable type later in your code. Ruby supports parallel assignment of variables. This is useful if you need
to assign values to a number of variables. To find out the variable type use the kind_of? method of the object class 
$ y.kind_of? Integer 
One of simplest ways to change the type of a variable is to simply assign a new value to it. Ruby will dynamically change the type for that
variable to match the type of the new value assigned
The Ruby variable classes have methods that can be called to convert their value to a different type. For example, the Fixnum class has a
method named to_f that can be used to retrieve the integer stored in a variable as a floating point value
Similarly, you can convert a Ruby integer to a string using the to_s() method. The to_s() method takes as an argument the number base to
which you want the conversion made. If no number base is specified, decimal is assumed. Convert to binary by specifying a number base of 2
convert to hexadecimal by specifying a number base of 16 or octal a number base of 8. In fact, we can use any number base between 1 and 36
when using the to_s method
=end 

=begin
Scope defines where in a program a variable is accessible. Ruby has four types of variable scope; local, global, instance and class. In
addition, Ruby has one constant type. Each variable type is declared by using a special character at the start of the variable name as 
outlined below:
$ Variable Scope is a global variable 
@ Variable Scope an instance variable 
a to z || _ Variable Scope is a local variable 
@@ Variable scope is a class variable 

In addition, Ruby has two pseudo-variables which cannot be assigned values. These are nil which is assigned to uninitialized variables and
self which refers to the currently executing object

Detecting the scope of a variable. A useful technique to find out the scope of a variable programmatically is to use the defined? method
defined? x returns the scope of the variable x referenced, or nil if the variable is not defined in the current context
=end 

=begin
Local variables are local to the code construct in which they are declared. For example, a local variable declared in a method or within a
loop cannot be accessed outside of that loop or method. Local variable names must begin with either an underscore or a lower case letter
=end 

=begin
Global variables in Ruby are accessible from anywhere in the Ruby program, regardless of where they are declared. Global variable names are
prefixed with a dollar sign ($). Use of global variables is strongly discouraged. The problem with global variables is that, not only are
they visible anywhere in the code for a program, they can also be changed from anywhere in the application. This can make tracking bugs difficult
Pre-defined global variables to obtain information about the Ruby environment:
$@  The location of latest error 
$_  The string last read by gets 
$.  The line number last read by interpreter 
$&  The string last matched by regexp 
$~  The last regexp match, as an array of subexpressions 
$n  The nth subexpression in the last match (same as $~[n]) 
$=  The case-insensitivity flag 
$/  The input record seperator 
$\  The output record seperator 
$0  The name of the ruby script file currently executing 
$*  The command line arguments used to invoke the script 
$$  The ruby interpreter's process ID 
$?  The exit status of the last executed child process   
=end 

=begin
A class variable is a variable that is shared amongst all instances of a class. This means that only one variable value exists for all 
objects instantiated from this class. This means that if one object instance changes the value of the variable, that new value will 
essentially change for all other object instances. Another way of thinking of class variables is as global variables within the context of 
a single class. Class variables are declared by prefixing the variable name with two @ characters (@@). Class variables must be initialized
at creation time. For example: @@total = 0 
=end 

=begin 
Instance variables are similar to Class variables except that their values are local to specific instances of an object. For example if a
class contains an instance variable called @total, if one instance of the object changes the current value of @total the change is local to
only the object that made the change. Other objects of the same class have their own local copies of the variable which are independent of
changes made in any other objects. Instance variables are declared in Ruby by prefixing the variable name with a single @ sign: @total = 10
=end 

$ctrl+l  #clears the screen shortcut 
*****************************Ruby Programming Language*****************************************
#A variable does not point to a variable. A variable points to the assignment of a variable
####String interpolation doesnt work with single quote 
name = "Rumman Ahmed"
"My name is #{name}"  #Prints out the value of the variable name 
###You cannot use signle quote within a single quote. To use single quote inside a string surround it with double quote or you can use the escape character \ to preceede the single quote 
###the stringvar.length method counts the space as a character 

To start irb console:  irb

***************Working with Strings**************************************************************************
String concat structure:  String1 + String2 || String1 + " " + String2 + String3

To find out what class the object belongs to:  Variable_name.class  ||  1.class

To find out methods available to an object:  objectname.methods

Some methods that can be used on objects:  objectname.nil?, objectname.empty?, objectname.length, objectname.reverse

String interpolation (remember has to be within double quotes):  name = "Mashrur" ==> "My name is #{name}"  ##This will print out the value of name in the line "My name is...."

To escape the evaluation of #{variablename} within a String, prepent with a \:  \#{variablename}

To get input from the command line use the following method:  gets.chomp

To assign the input to a variable so it can be referenced later on:  variablename = gets.chomp

puts "cat, dog, penguin".upcase

puts "CAT, DOG, PENGUIN".downcase

##This block of code takes a sentence as a user input and breaks it up word by word and displays the number of words in the sentence
puts "Please type a sentence"
user_sentence = gets 
number_of_words = user_sentence.split(" ").count 
puts "Your sentence had #{number_of_words} word#{number_of_words == 1 ? ".":"s."}"


******************Working with Numbers******************************************************************************
puts 1 + 2  #To add and display the value of 1 + 2
#Different operations
1 + 2  #Addition
1 * 2  #Multiplication
1 / 2  #Division
1 - 2  #Subtraction
1 % 2  #Modulus (gives the remainder when two numbers are divided)
20 is an integer, 20.0 is a float  #To indicate a number is a float instead of an integer include a . in the number or 20.to_f 
#Methods you can use to find odd and even number:
object.odd?
22.odd?
object.even?
22.even?
#odd number has a remainder of 1 and even number has a remainder of 0 
#Comparisons:
a == b
1 == 2
3 == 3
5 < 2
2 <= 5
5 > 2
5 && 6
5 || 6
#Generate a random number between 0 and less than 10
rand(10)  #Does not include 10 prints out a random number from 0-9
objectname.to_i or "5".to_i  #To convert an string object to integer
objectname.to_s or 5.to_s  #To convert an object to string


*****************************Conditionals************************************************************************
###Basic conditionals:
if my_variable > 10
  puts my_variable
end

###Extended Conditional 
if my_variable > 10 
  puts my_variable 
else
  puts "Too Small!"
end 

###Extended Condiditon: Elsif
if my_variable > 10
   ......
elsif my_variable < 10
   ......
else 
   ......
end 

###One Line Conditionals
puts "Big Number" if my_variable > 10

puts "Small Number" unless my_variable > 10   #unless acts like if except it is negated i.e. unless => if the condition is not met 

###Basic Negated Conditional  #unless can also function as a regular conditional statement which states if the condition is not met
unless my_variable > 10 
  puts my_variable 
end 

###Ternary Statement: Another way to write If Else statement in one line 
my_variable > 10 ? puts("big") : puts("small")


###Conditional can have more than one Elsif:
if my_var == 10
  ....
elsif my_var == 9
  ....
elsif my_var == 8
  ....
elsif my_var == 7
  ....
end 


###Case: (AKA switch)  #Simpler alternative to multiple elsif clauses
case my_var
  when 10
    ....
  when 9
    ....
  when 8
    ....
  when 7
    ....
end 

###Conditionals can test multiple conditions at once 
#Boolean AND &&
if my_var == 10 && your_var == 5 
  ....
end 
###If my_var == 9 the condition is automatically false and the second condition is not tested 

#Boolean OR ||
if my_var == 10 || your_var == 5
  ....
end 
###If my_var == 10 the condition is automatically true and the second condition is not tested 

###Conditions can be negated 
#NOT ! 
if !my_var == 10
  ....
end 
###If my_var == 10 then !my_var says change that true to a false and vice-versa. This is called negating 


###We can also test for inequality 
if my_var != 10 
  ....
end 


###We can also test strings 
if my_var == "Y"
  ....
elsif my_var == "N"
  ....
else 
  ....
end 


**********************Basic Comparison Tests*********************************************************************  
a > b   #Greater than 
a < b   #Less than 
a >= b  #Greater than or equal 
a <= b  #Less than or equal 
a == b  #Equal 


**************************************Loops******************************************************************************
###While Loop: repeats a section of code as long as a specific condition is true. Generally requires the condition to change 
#as the loop executes in order to avoid infinite loops
#while loop example: 
my_var = 10 
while my_var < 30 do
  puts "my_var = #{my_var}"
  my_var += 1
end 

#loops and arrays are the perfect match: incremental index in the array. Incrementing value of test condition variable 
pets = ["cats", "dogs", "ducks", "chickens", "fish"]
pet_index = 0
while pet_index < pets.count do
  if pets[pet_index] == "ducks" || pets[pet_index] == "chickens"
    pets[pet_index] = nill
  end
  pet_index += 1 
end 

#Write a program that asks the user for 10 integers. Then sort the integers from least to greatest. Output the sorted 
#list to the user 
integers = []
current_integer = 0 
while current_integer < 10 do 
  puts "Type an integer"
  integers[current_integer] = gets.to_i 
  current_integer += 1 
end 
integers.sort.each do |this_int|
  puts this_int 
end 



###until loop: the inverse of while 
my_var = 10

until my_var > 30 do
  puts "my_var = #{my_var}" 
  my_var += 1
end 


###for loop example: 
bags = ["suitcase", "messenger bag", "satchel", "backpack"]

for bag_type in bags do 
  puts bag_type
end 

#For Loop inclusive range includes 1,2,3,&4:
for variable in 1..4 do
  ......
end 

#For Loop exclusive range includes 1,2,3 excludes 4: 
for variable in 1...4 do
  ......
end 

**********************************************Loop Control******************************************************
###The keyword next skips the rest of the iteration and moves to the next iteration if the condition is still true 

my_var = 0
while my_var < 10 do 
  if my_var == 3 
    my_var += 1
    next
  end 
  puts my_var
  my_var += 1 
end 

###The keyword redo goes to the begining of the iteration of the loop, wether or not the condition is true
#Redo doesn't check the condition of the loop before redoing the current iteration

my_var = 0 
while my_var < 10 do 
  puts my_var 
  if my_var == 3 
    my_var = 10
    redo 
  end 
  my_var += 1
end 

###The keyword break exit the loop immediately 

puts "Type something to continue. Or nothing to quit"
while a = gets do 
  
  if a == "\n"
    break
  end
  puts a 
end 

#Another example of the keyword break Adding Machine 

total = 0
puts "Input your numbers"
while input = gets do 
  if input == "\n"
    break
  end 
  total = total + input.to_f 
  puts "running total = #{total}"
end 

puts "Total: #{total}" 

  

*************************************Methods and Branching*************************************************
def hello_user
  puts "Enter your name"
  username = gets 
  if username != "\n"
    "Hello #{username.chop}."
  else 
    false
  end
end 

*****************************************

def double_my_number number
  number *=2
end 

*****************************************

def double_my_number number = 42
  number *=2
end 

********************************************
###Methods that take program blocks:

def my_method 
  puts "executing your code ..."
  yield
  puts "done"
end 

my_method do 
  puts 2 + 2
end 


*****************************************

def multiply(first_number, second_number)
  first_number.to_f * second_number.to_f
end

def divide(first_number, second_number)
  first_number.to_f / second_number.to_f
end

def subtract(first_number, second_number)
  second_number.to_f - first_number.to_f
end

def mod(first_number, second_number) 
  first_number.to_f % second_number.to_f
end

puts "What would you like to do 1)Multiply, 2)Divide, 3)Subtract, 4)Mod"
prompt = gets.chomp 

puts "Please enter First Number"
first_number = gets.chomp
puts "PLease enter Second Number"
second_number = gets.chomp

if prompt == '1'
  puts "You have choosen to multiuply #{first_number} with #{second_number}"
  result = multiply(first_number, second_number)
elsif prompt == '2'
  puts "YOu have choosen to divide #{first_number} with #{second_number}"
  result = divide(first_number, second_number)
elsif prompt == '3'
  puts "You have choosen to subtract #{second_number} from #{first_number}"
  result = subtract(first_number, second_number)
elsif prompt == '4'
  puts "You have choosen to mod #{first_number} with #{second_number}"
  result = mod(first_number, second_number)
else
  puts "You have made an invalid choice"
end 

puts "The result is #{result}"

************************************************

def multiply_this a, b
  total = a * b
  if total < 0
    false
  else 
    total
  end
end

user_input = []
puts "Input two numbers"
while user_number = gets do 
  user_input[user_input.count] = user_number.to_f 
  if user_input.count == 2 
    break
  end
end 
if result = multiply_this(user_input[0], user_input[1])
  puts result
else 
  puts "invalid Input"
end 


************************************************

def get_ingredient 
  new_ingredient = gets 
  if new_ingredient != "\n"
    new_ingredient 
  else
    false
  end 
end 
ingredients = []
puts "Input your ingredients"
while my_ingredient = get_ingredient do 
  ingredients[ingredients.count] = my_ingredient 
end
puts "Input your instructions"
instructions = gets 
puts "Ingredients:"
puts ingredients 
puts "Instructions:"
puts instructions   

**************************************************Iterators************************************************************************************
#Iterators are special block of code that can operate a statement of code on each member of a data collection
#Iterators are useful because it acts as a program loops for collection 
#DRY means do not repeat yourself an important fundamental of programming 
first_five_integers = [1, 2, 3, 4, 5]

#Typing it out 
puts first_five_integers[0]
puts first_five_integers[1]
puts first_five_integers[2]
..........

#Iteratoring through the array 
first_five_integers.each do |my_integer|
  puts my_integer 
end 

#Iteratoring through a hash 
my_hash = {"orange" => true, "banana" => false}
my_hash.each do |key, value|
  puts "The key is #{key} and it s value is #{value}"
end 



***********************************Ranges************************************************************************************************************
#Ruby Ranges allow data to be represented in the form of a range as a data set with start and end values and a logical sequence of values in between
#The values in a range can be numbers, characters, strings or objects
#Sequence ranges in Ruby are used to create a range of successive values - consisting of a start value, an end value and a range of values in between
#Two operators are available for creating such ranges, the inclusive two-dot (..) operator and the exclusive three-dot operator (...)
1..10  # Creates a range from 1 to 10 inclusive
1...9  # Creates a range from 1 to 9
(1..10).to_a  #A range may be converted to an array using the Ruby to_a method
("a".."l").to_a  #ranges are not restricted to numerical values. We can also create a character based range
("cab".."car").to_a   #ranges based on string values
#Methos of the range object 
range = 'cab'..'car'
range.min
range.max
range.include?('value')
range.reject {|subrange| subrange < 'value'}  # reject values below a specified range value 
range.each {|ranges| puts "Hello" + " " + ranges}

################Ranges used in conjunction with a case statement

#!/usr/bin/ruby 

score = 70

result = case score
  when 0..40 then "Fail"
  when 41..60 then "Pass"
  when 61..70 then "Pass with Merit"
  when 71..100 then "Pass with distinction"
  else "invalid Score"
end 

puts result 


************************************************Arrays and Iterators**************************************************************************
#An Array is an ordered list of objects and elements. It maintains an index for each item so you can access those elements 
#An Array 
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, "Rumman", [1, 2, 3]]
#Since Arrays have an index associated with each object they are very easy to grab item from the Array to display them 
a[1]
puts a
a.empty?
a.include?("Rumman")
a.delete("value") 
a.reverse
a.reverse!   #mutates the caller
a.shuffle
(0..25).to_a  #takes a range of 0 to 25 and creates an array
y = (0..99).to_a.shuffle!  #takes a range of 0 to 99 creates an array and shuffle the numbers inside the array
z = (0..10).to_a
z
z << 25  #adds an element to an array
z.push(30) #Another way of adding an object to an array 
z.unshift("Rumman")  #Adds an element to the begining of the array 
z[0]
z.pop   #deletes an object from the end of an array 
z.uniq  #hides duplicate elements in an array 
z.uniq! #mutates the caller the duplicates are gone
y.each {|i| puts i}  #to iterate through an array use the .each method. It loops through an array 
#Using the for loop to iterate through an array 
for number in y
  puts "Hi"
end 

#Creating an array of strings
names = ["joe", "john", "james"]
#To iterate over the array and print the names with a hello salutation
names.each do |food|
puts "Hello #{food}"
end 

names.each do |food|
puts "Hello #{food.capitalize}"
end 

names.each { |food| puts "Hello #{food.capitalize}" }   #one liner 

y.select { |number| number.odd? }  #The select method takes a boolean expression to evaluate and if that boolean expression evaluates to true its basically gets the number 
y.each { |number| print number if number.odd? }  #another way of iterating the array and printing out the odd numbers 

p = ["My", "name", "is", "Rumman"]
p.join
p.join(' ') 

#######Nested Arrays: (aka multi-dimensional arrays)
childhood_games_played = [["make believe", true], ["tag", false]] 
childhood_games_played[0][0]  #will return "make believe"
childhood_games_played[1][0]  #will return "tag"
childhood_games_played[0][1]  #will return true 
childhood_games_played[1][1]  #will return false


#Array, created by including elements within square brackets:

a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

#The index for an array starts with 0, so in the array above a[0] is 1

#Some methods you can use on arrays:

arrayname.empty?

arrayname.include?(itemname)

arrayname.reverse

arrayname.reverse! # use ! at the end to change the original array

arrayname.shuffle

arrayname.push(30) # will append new element 30 to the end array

arrayname << 25 # << known as shovel operator will also append new element to the end of the array

arrayname.unshift("someelement") # will add element "some element" to the beginning of the array

arrayname.pop # will remove the last element of the array and return 1

arrayname.uniq # will remove all the duplicates and display (will not change the original array)

arrayname.uniq! # will remove all the duplicates in the original array

#A range:

(0..25).to_a

#will create an array with elements from value 0 to 25

(0..99).to_a.shuffle!

#will create an array with elements from value 0 to 99 in random order

#To loop through an array named y using the .each method and print out the value of each element:

y.each { |i| puts i }

#In plain terms: For each element i in array y print the value of i

To execute iteration through an array called names using a block:

names.each do |randomvariablename| # starts the do block

puts "Hello #{randomvariablename}" # executes code for each element

end # ends the do block

#To capitalize (or use another method) on each element of array called names:

names.each { |randomvariablename| puts "Hello #{randomvariablename.capitalize}" }

#Using the select method to pickup all the odd numbers from an array y:

y.select { |number| number.odd? } # selects the value and returns it only if the condition is met

#To join the elements of an array named p:

p.join

#To join the elements of an array with space in between each element:

p.join(" ")

To join the elements of an array with dash in between each element:

p.join("-")

my_array.sort 
my_array.sort!

#Sorting with a block of code 
my_array.sort do |a,b|
  a <=> b
end 

#Build an array off of data in an array 
my_array = [1, 2, 3]

odd_or_even = my_array.map do |element|
  element % 2 == 0 ? "even" : "odd"
end 

*************************************************************HASHES************************************************************************************************************
#Like Array a hash is a data structure that stores values but unlike array a hash also has keys associated with those values. Hash exist in a key value pair
#The key is usually a symbol but it can be other things as well like a string and the values can be any data type
#Creating a hash with key as strings
my_details = {'name' => 'rumman', 'favcolor' => 'green'}
my_details["favcolor"]  #To call a hash refer to the key 
#creating a hash with key as symbols
myhash = {a: 1, b: 2, c: 3, d: 4} 
myhash[:c]  #to call the value refer to the symbol 
myhash[:e] = 7  #to add value to the hash 
myhash[:name] = "Rumman"
myhash.delete(:b)  #to delete a value from hash 

#To create a hash
number = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8, i: 9}
#To iterate through a hash
number.each { |k, v| puts "The key is #{k}, and the value is #{v}" }
#To iterate through a hash and delete multiple values 
number.each { |k, v| number.delete(k) if v > 3 }
#To select the odd number in the hash
number = {a: 1, b: 2, c: 3, d: 5, e: 9}
number.select { |k, v| v.odd? }

######Nested Hashes: 
cocktails = {"martini" => {"vodka" => true, "gin" => false}}
cocktails["martini"]["vodka"]  #will return true
cocktails["martini"]["gin"]    #will return false 


#To create a hash called my_details include the elements within { }:

my_details = {'name' => 'mashrur', 'favcolor' => 'red'}

To access the value and notify me what favcolor is:

my_details["favcolor"]

Alternate syntax to create key, value pairs in hash:

myhash = {a: 1, b: 2, c: 3, d: 4}

To access the value for key c above:

myhash[:c]

To add a key,value pair to the hash above:

myhash[:d] = 7

myhash[:name] = "Mashrur"

To delete a key,value pair simply delete the key:

myhash.delete(:d)

To iterate through a hash using .each method and print out value:

myhash.each { |somekey, somevalue| puts somevalue }

To iterate through a hash using .each method and print out both key and value in friendly format:

myhash.each { |somekey, somevalue| puts "The key is #{somekey} and the value is #{somevalue}" }

To iterate through and delete a items from a hash based on a condition (in the condition below if the value is greater than 3:

myhash.each { |k, v| myhash.delete(k) if v > 3 }

Use select method to display items only if value of the item is odd

myhash.select { |k, v| v.odd? }



*************************************Object Oriented Programming(OOP)************************************************************************************************
/**
*Object-oriented programming (OOP) is a programming paradigm that uses objects and their interactions to design and program applications
*Allows the programming to block off areas of code that perform certain tasks independently of other areas in the application 
*
*#Classes: It is a blueprint that describes the state and behavior that the objects of the class all share. A class can be used to create 
*many objects. Objects created at runtime from a class are called instances of that particular class
*
*#Abstraction: Is simplifying a complex process of a program, an enterprise software solution for example by modeling classes 
*appropriate for it 
*
*#Inheritance: Is used where a class inherits the behavior of another class, referred to as the superclass. The class from which 
*the behavior is inherited is called the super class and the class that inheriting that behavior is called the subclass
*
*#Encasulation: Concept of blocking off areas of code and not making it available to the rest of the program 
*
*#Polymorphism: Is when a class inherits the behaviors of another class, but has the ability to not inherit everything and change some
*of it's inherited behaviors. For example to write a method that does something differently from the inherited method  

################Concept Code
class User  #Class declaration
  
  def initialize(name)   #This is the constructor method which initializes the object in other words resets the instance variable whenever a new object is created 
    @name = name
  end
  
  def run               #Instance method part of the User class 
    puts "Hi I am running"
  end 
     
end

user = User.new("Rumman")  #Initalization of an object of the User class 

puts User.ancestors  #Lists out all of the super classes of the User class  

puts user 


**************************Getter and Setter Methods*********************************
class User    #Class declaration 
  
  def initialize(name)   #The constructor 
    @name = name         #@name is the instance variable 
  end
  
  def run                #The run method is the instance method of the class User 
    puts "Hi I am running 
  end 
  
  def get_name   #This is the getter method for the class User 
    @name
  end
  
  def set_name=(name)  #This is the Setter method for the class User 
    @name = name 
  end 
end 

user = User.New("Rumman")
puts user.get_name 
user.set_name = "John"
puts user.get_name 

***************Shortcut for Getter and Setter Methods******************************
class User    #Class declaration 
  attr_accessor :name, :email   #This is the shortcut for getter and setter methods of the class 
  def initialize(name, email)    #The constructor method initializes the instance variable of the object when the object gets created 
    @name = name                 #@name, @email these two are the instance variable of the object it exists as long as the object exists and gets a fresh copy whenever a new object is created 
	@email = email
  end 
  
  def run                        #This is the instance method of the objects of the User class 
    puts "Hi I am running"
  end 
end

user = User.new("Rumman", "rumman@example.com")
puts "My user's name is #{user.name} and his email is #{user.email}"
user.name = "John"
user.email = "john@example.com"
puts "My user's new name is #{user.name} and his email is #{user.email}"





#################Class Method : A class method can be called directly on the class without instantiating any objects 

class User
  attr_accessor :name, :email 
  
  def initialize(name , email)
    @name = name 
	@email = email 
  end 
  
  def run 
    puts "Hi I am running"
  end 
  
  def self.identify_yourself    #This is a class method declared with self. 
    puts "Hey I am a class method"
  end 
end 

User.identify_yourself   #A class method can be called directly on the class without instantiating any objects


################Inheritance and Polymorphism 

class User   #Class Declaration 
  attr_accessor :name, :email    #Shortcut for getter and setter method 
  
  def initialize(name, email)           #Constructor @name and @email are the two instance variables  
    @name = name 
	@email = email 
  end 
  
  def run                        #Instance method 
    puts "Hi I am running"
  end 
end 

class Buyer < User               #Inheritance. The buyer sub class is inheriting the behaviors of the User super class 
  def run            #Polymorphism. The behavior of the run instance method of the User class is being modified in the Buyer sub class 
    puts "Hi I am not running from the Buyer class" 
  end 
end 

class Seller < User        #Inheritance

end

class Admin < User         #Inheritance 

end 

user = User.new("name", "name@example.com"_)   #Initializing an object of the User class
puts "My user's name is #{user.name} and his email is #{user.email}"

buyer1 = Buyer.new("name1", "name1@example.com")  #Initializing an object of the Buyer class 
buyer.run

seller1 = Seller.new("name2", "name2@example.com")   #Initializing an object of the Seller class 
seller1.run

admin1 = Admin.new("name3", "name3@example.com")     #Initializing an object of the admin class 
admin.run 



###############Module : A Module is similar to a class but, it basically is a collection of behaviors that other classes can use via mixins
#You have to include the Module in the class that you want to use but you cannot have an object of a module 
#You cannot initiate an instance variable of a Module. A Module has to be mixed in to a class and then you can use the methods in a Module 
#By naming convention Modules should have a name ending with able

module Destructable 
  
  def destroy(anyobject)
    puts "I will destroy the object"
  end 
  
end 

class User 
  include Destructable
  
  attr_accessor :name, :email 
  
  def initialize(name, email)
    @name = name 
	@email = email 
  end 
  
#This is a instance method    
  def run 
    puts "Hi I am running"
  end 
  
#This is the class method 

  def self.identify_yourself 
    puts "Hey I am a class method"
  end  
  
end 

User.identify_yourself 

user = User.new("Rumman", "rumman@example.com")

user.destroy("myname") 






=============================Section2 Project=======================================================================
#####Create user_permissions_template.json file
{"accounts": "read",
 "policies": "write",
 "users": "write"}
 
#######Create the user.rb User class 
require 'json'

class User

  attr_accessor :email, :name, :permissions
  
  def initialize(*args)
    @email = args[0]
	@name = args[1]
	@permissions = User.permissions_from_template
  end 
  
  def self.permissions_from_template 
    file = File.read 'user_permissions_template.json' 
	JSON.load(file, nil, symbolize_names: true)
  end 
  
  def save 
    self_json = {email: @email, name: @name, permissions: @permissions}.to_json
    open('users.json', 'a') do |file|
	  file.puts self_json
	end 
  end 
end 

###Create runner.rb 
require 'pp'
require_relative 'user'

user = User.new 'joe@example.com', 'joe'

pp user 

user.save 




*****************************************************Desk.rb************************************************************************************************
#!/usr/bin/ruby 

puts "Hello"
puts "Do you have a phone (Y/N)?"
case gets 
  when "Y\n"
    phone = true
  when "N\n"
    phone = false 
end 

puts "Do you have a pencil (Y/N)?"
case gets 
  when "Y\n"
    pencil = true 
  when "N\n"
    pencil = false 
end 

puts "You have a phone" if phone 
puts "You have a pencil" if pencil 



************************************************************Grocery_Item.rb************************************************************************************
#!/usr/bin/ruby 

grocery_items = {orange: false, banana: false}
puts "Do you need:" 
grocery_items.each do |item, need_for_item|
  puts item.to_s + "? (Y/N)"
  case gets 
    when "Y\n"
      grocery_items[item] = true
    when "N\n"
      grocery_items[item] = false 
  end 
end 

puts "Here's your list:"
grocery_items.each do |item, need_for_item|
  puts item if need_for_item 
end 



************************************************Ruby Style Guide*************************************************************************************
#Use UTF-8 as the source file encoding
#Use two spaces per indentation level (aka soft tabs). No hard tabs
def some_method
  do something 
end 

/**
*Use Unix-style line endings. (*BSD/Solaris/Linux/macOS users are covered by default, Windows users have to be extra careful.)
*If you're using Git you might want to add the following configuration setting to protect your project from Windows line endings creeping in:
*git config --global core.autocrlf true
*
*
*/
